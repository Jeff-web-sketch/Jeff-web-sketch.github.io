<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pickle Type</title>
<link rel="icon" type="image/jpeg" href="output (2).jpg">
<style>
    body {
        background-color: #1a1a1a;
        color: #fff;
        font-family: monospace;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
    }
    h1 {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    #countdown {
        font-size: 2rem;
        margin-bottom: 20px;
    }
    #textDisplay {
        font-size: 1.5rem;
        max-width: 800px;
        line-height: 2rem;
        margin-bottom: 20px;
    }
    .current-char {
        background-color: yellow;
        color: black;
    }
    .correct {
        color: lime;
    }
    .incorrect {
        color: red;
    }
    #stats {
        font-size: 1.2rem;
    }
    #endScreen {
        display: none;
        text-align: center;
    }
</style>
</head>
<body>

<h1>ü•í Pickle Type</h1>
<div id="countdown">3</div>
<div id="textDisplay"></div>
<div id="stats">
    WPM: <span id="wpm">0</span> | Accuracy: <span id="accuracy">100</span>%
</div>
<div id="endScreen">
    <h2>üèÅ Finished!</h2>
    <p>Your WPM: <span id="finalWpm"></span></p>
    <p>Your Accuracy: <span id="finalAccuracy"></span>%</p>
</div>

<script>
const sentences = [
    "Pickles are crunchy, green, and perfect for typing practice in Pickle Type.",
    "If you can type this sentence without mistakes, you are a true pickle typing champion.",
    "Some pickles are sweet, some are sour, but all are delicious in their own way.",
    "A jar of pickles is like a jar of motivation for your typing journey.",
    "Typing fast and accurately is as satisfying as opening a fresh jar of dill pickles."
];

let currentSentence = "";
let currentIndex = 0;
let startTime = null;
let correctCount = 0;
let typedCount = 0;
let timer;
let running = false;

const textDisplay = document.getElementById("textDisplay");
const wpmSpan = document.getElementById("wpm");
const accuracySpan = document.getElementById("accuracy");
const countdownDiv = document.getElementById("countdown");
const endScreen = document.getElementById("endScreen");
const finalWpm = document.getElementById("finalWpm");
const finalAccuracy = document.getElementById("finalAccuracy");

function startCountdown() {
    let count = 3;
    countdownDiv.textContent = count;
    const countdownTimer = setInterval(() => {
        count--;
        countdownDiv.textContent = count > 0 ? count : "Go!";
        if (count < 0) {
            clearInterval(countdownTimer);
            countdownDiv.style.display = "none";
            startGame();
        }
    }, 1000);
}

function startGame() {
    currentSentence = sentences[Math.floor(Math.random() * sentences.length)];
    currentIndex = 0;
    correctCount = 0;
    typedCount = 0;
    startTime = new Date();
    running = true;
    displaySentence();
    document.addEventListener("keydown", handleTyping);
    timer = setInterval(updateStats, 100);
}

function displaySentence() {
    textDisplay.innerHTML = "";
    for (let i = 0; i < currentSentence.length; i++) {
        const span = document.createElement("span");
        span.textContent = currentSentence[i];
        if (i === currentIndex) span.classList.add("current-char");
        textDisplay.appendChild(span);
    }
}

function handleTyping(e) {
    if (!running) return;
    const key = e.key;
    if (key.length !== 1) return; // ignore special keys

    const spans = textDisplay.querySelectorAll("span");
    if (currentIndex < currentSentence.length) {
        const currentChar = currentSentence[currentIndex];
        if (key === currentChar) {
            spans[currentIndex].classList.remove("current-char");
            spans[currentIndex].classList.add("correct");
            correctCount++;
        } else {
            spans[currentIndex].classList.remove("current-char");
            spans[currentIndex].classList.add("incorrect");
        }
        typedCount++;
        currentIndex++;
        if (currentIndex < currentSentence.length) {
            spans[currentIndex].classList.add("current-char");
        } else {
            endGame();
        }
    }
}

function updateStats() {
    const elapsedMinutes = (new Date() - startTime) / 60000;
    const wpm = Math.round((correctCount / 5) / elapsedMinutes);
    const accuracy = typedCount > 0 ? Math.round((correctCount / typedCount) * 100) : 100;
    wpmSpan.textContent = wpm;
    accuracySpan.textContent = accuracy;
}

function endGame() {
    running = false;
    clearInterval(timer);
    document.removeEventListener("keydown", handleTyping);
    finalWpm.textContent = wpmSpan.textContent;
    finalAccuracy.textContent = accuracySpan.textContent;
    endScreen.style.display = "block";
}

startCountdown();
</script>

</body>
</html>
